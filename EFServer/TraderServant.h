// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __TRADERSERVANT_H_
#define __TRADERSERVANT_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace Center
{
    struct userLoginRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.userLoginRequest";
        }
        static string MD5()
        {
            return "c454b42c223757836fc3e42415c3af37";
        }
        userLoginRequest()
        :typeId(""),requestId(0),brokerId(""),userId(""),password(""),userProductInfo(""),forcedreset(0)
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            brokerId = "";
            userId = "";
            password = "";
            userProductInfo = "";
            forcedreset = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(brokerId, 3);
            _os.write(userId, 4);
            _os.write(password, 5);
            if (userProductInfo != "")
            {
                _os.write(userProductInfo, 6);
            }
            if (forcedreset != 0)
            {
                _os.write(forcedreset, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(brokerId, 3, true);
            _is.read(userId, 4, true);
            _is.read(password, 5, true);
            _is.read(userProductInfo, 6, false);
            _is.read(forcedreset, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(brokerId,"brokerId");
            _ds.display(userId,"userId");
            _ds.display(password,"password");
            _ds.display(userProductInfo,"userProductInfo");
            _ds.display(forcedreset,"forcedreset");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(brokerId, true);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(password, true);
            _ds.displaySimple(userProductInfo, true);
            _ds.displaySimple(forcedreset, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string brokerId;
        std::string userId;
        std::string password;
        std::string userProductInfo;
        tars::Int32 forcedreset;
    };
    inline bool operator==(const userLoginRequest&l, const userLoginRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.brokerId == r.brokerId && l.userId == r.userId && l.password == r.password && l.userProductInfo == r.userProductInfo && l.forcedreset == r.forcedreset;
    }
    inline bool operator!=(const userLoginRequest&l, const userLoginRequest&r)
    {
        return !(l == r);
    }

    struct userLoginResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.userLoginResponse";
        }
        static string MD5()
        {
            return "9c2426dcf872b66b145cac9836e1fe56";
        }
        userLoginResponse()
        :typeId(""),requestId(0),errcode(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
    };
    inline bool operator==(const userLoginResponse&l, const userLoginResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const userLoginResponse&l, const userLoginResponse&r)
    {
        return !(l == r);
    }

    struct userLogoutRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.userLogoutRequest";
        }
        static string MD5()
        {
            return "0215fe29d5bfaa33fed62c1ea82c85e3";
        }
        userLogoutRequest()
        :typeId(""),requestId(0),brokerId(""),userId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            brokerId = "";
            userId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(brokerId, 3);
            _os.write(userId, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(brokerId, 3, true);
            _is.read(userId, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(brokerId,"brokerId");
            _ds.display(userId,"userId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(brokerId, true);
            _ds.displaySimple(userId, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string brokerId;
        std::string userId;
    };
    inline bool operator==(const userLogoutRequest&l, const userLogoutRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.brokerId == r.brokerId && l.userId == r.userId;
    }
    inline bool operator!=(const userLogoutRequest&l, const userLogoutRequest&r)
    {
        return !(l == r);
    }

    struct userLogoutResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.userLogoutResponse";
        }
        static string MD5()
        {
            return "9c2426dcf872b66b145cac9836e1fe56";
        }
        userLogoutResponse()
        :typeId(""),requestId(0),errcode(0),errmsg("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
    };
    inline bool operator==(const userLogoutResponse&l, const userLogoutResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg;
    }
    inline bool operator!=(const userLogoutResponse&l, const userLogoutResponse&r)
    {
        return !(l == r);
    }

    struct tradeItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.tradeItem";
        }
        static string MD5()
        {
            return "9b8e9e1008487eecadcd24ac60903106";
        }
        tradeItem()
        :tradeId(""),direction(0),price(0),volume(0),tradeDate(""),tradeTime("")
        {
        }
        void resetDefautlt()
        {
            tradeId = "";
            direction = 0;
            price = 0;
            volume = 0;
            tradeDate = "";
            tradeTime = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(tradeId, 1);
            _os.write(direction, 2);
            _os.write(price, 3);
            _os.write(volume, 4);
            _os.write(tradeDate, 5);
            _os.write(tradeTime, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(tradeId, 1, true);
            _is.read(direction, 2, true);
            _is.read(price, 3, true);
            _is.read(volume, 4, true);
            _is.read(tradeDate, 5, true);
            _is.read(tradeTime, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(tradeId,"tradeId");
            _ds.display(direction,"direction");
            _ds.display(price,"price");
            _ds.display(volume,"volume");
            _ds.display(tradeDate,"tradeDate");
            _ds.display(tradeTime,"tradeTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(tradeId, true);
            _ds.displaySimple(direction, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(volume, true);
            _ds.displaySimple(tradeDate, true);
            _ds.displaySimple(tradeTime, false);
            return _os;
        }
    public:
        std::string tradeId;
        tars::Int32 direction;
        tars::Double price;
        tars::Int32 volume;
        std::string tradeDate;
        std::string tradeTime;
    };
    inline bool operator==(const tradeItem&l, const tradeItem&r)
    {
        return l.tradeId == r.tradeId && l.direction == r.direction && l.price == r.price && l.volume == r.volume && l.tradeDate == r.tradeDate && l.tradeTime == r.tradeTime;
    }
    inline bool operator!=(const tradeItem&l, const tradeItem&r)
    {
        return !(l == r);
    }

    struct orderOpenRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.orderOpenRequest";
        }
        static string MD5()
        {
            return "9dfd9dc7e0109c620562ae3337442889";
        }
        orderOpenRequest()
        :typeId(""),requestId(0),brokerId(""),userId(""),instrumentId(""),orderDirection(0),volumeTotalOriginal(0),orderTimeout(5000)
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            brokerId = "";
            userId = "";
            instrumentId = "";
            orderDirection = 0;
            volumeTotalOriginal = 0;
            orderTimeout = 5000;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(brokerId, 3);
            _os.write(userId, 4);
            _os.write(instrumentId, 5);
            _os.write(orderDirection, 6);
            _os.write(volumeTotalOriginal, 7);
            if (orderTimeout != 5000)
            {
                _os.write(orderTimeout, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(brokerId, 3, true);
            _is.read(userId, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(orderDirection, 6, true);
            _is.read(volumeTotalOriginal, 7, true);
            _is.read(orderTimeout, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(brokerId,"brokerId");
            _ds.display(userId,"userId");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(orderDirection,"orderDirection");
            _ds.display(volumeTotalOriginal,"volumeTotalOriginal");
            _ds.display(orderTimeout,"orderTimeout");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(brokerId, true);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(orderDirection, true);
            _ds.displaySimple(volumeTotalOriginal, true);
            _ds.displaySimple(orderTimeout, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string brokerId;
        std::string userId;
        std::string instrumentId;
        tars::Int32 orderDirection;
        tars::Int32 volumeTotalOriginal;
        tars::Int32 orderTimeout;
    };
    inline bool operator==(const orderOpenRequest&l, const orderOpenRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.brokerId == r.brokerId && l.userId == r.userId && l.instrumentId == r.instrumentId && l.orderDirection == r.orderDirection && l.volumeTotalOriginal == r.volumeTotalOriginal && l.orderTimeout == r.orderTimeout;
    }
    inline bool operator!=(const orderOpenRequest&l, const orderOpenRequest&r)
    {
        return !(l == r);
    }

    struct orderOpenResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.orderOpenResponse";
        }
        static string MD5()
        {
            return "b1f0d280d24ced09d047ce09492e8dd1";
        }
        orderOpenResponse()
        :typeId(""),requestId(0),errcode(0),errmsg(""),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
            _os.write(instrumentId, 5);
            _os.write(tradeArrayItems, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(tradeArrayItems, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(tradeArrayItems,"tradeArrayItems");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(tradeArrayItems, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
        std::string instrumentId;
        vector<Center::tradeItem> tradeArrayItems;
    };
    inline bool operator==(const orderOpenResponse&l, const orderOpenResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg && l.instrumentId == r.instrumentId && l.tradeArrayItems == r.tradeArrayItems;
    }
    inline bool operator!=(const orderOpenResponse&l, const orderOpenResponse&r)
    {
        return !(l == r);
    }

    struct orderCloseRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.orderCloseRequest";
        }
        static string MD5()
        {
            return "fb4a2ce3cb683532cc40069a6599f831";
        }
        orderCloseRequest()
        :typeId(""),requestId(0),brokerId(""),userId(""),instrumentId(""),orderDirection(0),orderVolume(0)
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            brokerId = "";
            userId = "";
            instrumentId = "";
            orderDirection = 0;
            orderVolume = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(brokerId, 3);
            _os.write(userId, 4);
            _os.write(instrumentId, 5);
            _os.write(orderDirection, 6);
            _os.write(orderVolume, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(brokerId, 3, true);
            _is.read(userId, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(orderDirection, 6, true);
            _is.read(orderVolume, 7, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(brokerId,"brokerId");
            _ds.display(userId,"userId");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(orderDirection,"orderDirection");
            _ds.display(orderVolume,"orderVolume");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(brokerId, true);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(orderDirection, true);
            _ds.displaySimple(orderVolume, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string brokerId;
        std::string userId;
        std::string instrumentId;
        tars::Int32 orderDirection;
        tars::Int32 orderVolume;
    };
    inline bool operator==(const orderCloseRequest&l, const orderCloseRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.brokerId == r.brokerId && l.userId == r.userId && l.instrumentId == r.instrumentId && l.orderDirection == r.orderDirection && l.orderVolume == r.orderVolume;
    }
    inline bool operator!=(const orderCloseRequest&l, const orderCloseRequest&r)
    {
        return !(l == r);
    }

    struct orderCloseResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.orderCloseResponse";
        }
        static string MD5()
        {
            return "b1f0d280d24ced09d047ce09492e8dd1";
        }
        orderCloseResponse()
        :typeId(""),requestId(0),errcode(0),errmsg(""),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
            _os.write(instrumentId, 5);
            _os.write(tradeArrayItems, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(tradeArrayItems, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(tradeArrayItems,"tradeArrayItems");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(tradeArrayItems, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
        std::string instrumentId;
        vector<Center::tradeItem> tradeArrayItems;
    };
    inline bool operator==(const orderCloseResponse&l, const orderCloseResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg && l.instrumentId == r.instrumentId && l.tradeArrayItems == r.tradeArrayItems;
    }
    inline bool operator!=(const orderCloseResponse&l, const orderCloseResponse&r)
    {
        return !(l == r);
    }

    struct instrumentQueryRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.instrumentQueryRequest";
        }
        static string MD5()
        {
            return "bed05919c3d64eb43899b8d1fbfbd341";
        }
        instrumentQueryRequest()
        :typeId(""),requestId(0),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(instrumentId, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(instrumentId, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(instrumentId,"instrumentId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(instrumentId, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string instrumentId;
    };
    inline bool operator==(const instrumentQueryRequest&l, const instrumentQueryRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.instrumentId == r.instrumentId;
    }
    inline bool operator!=(const instrumentQueryRequest&l, const instrumentQueryRequest&r)
    {
        return !(l == r);
    }

    struct instrumentQueryResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.instrumentQueryResponse";
        }
        static string MD5()
        {
            return "129ff878728cedad09bc4068a3334131";
        }
        instrumentQueryResponse()
        :typeId(""),requestId(0),errcode(0),errmsg(""),instrumentId(""),instrumentName(""),maxMarketOrderVolume(0),minMarketOrderVolume(0),volumeMultiple(0),priceTick(0),createDate(""),openDate(""),expireDate("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
            instrumentId = "";
            instrumentName = "";
            maxMarketOrderVolume = 0;
            minMarketOrderVolume = 0;
            volumeMultiple = 0;
            priceTick = 0;
            createDate = "";
            openDate = "";
            expireDate = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
            _os.write(instrumentId, 5);
            _os.write(instrumentName, 6);
            _os.write(maxMarketOrderVolume, 7);
            _os.write(minMarketOrderVolume, 8);
            _os.write(volumeMultiple, 9);
            _os.write(priceTick, 10);
            _os.write(createDate, 11);
            _os.write(openDate, 12);
            _os.write(expireDate, 13);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(instrumentName, 6, true);
            _is.read(maxMarketOrderVolume, 7, true);
            _is.read(minMarketOrderVolume, 8, true);
            _is.read(volumeMultiple, 9, true);
            _is.read(priceTick, 10, true);
            _is.read(createDate, 11, true);
            _is.read(openDate, 12, true);
            _is.read(expireDate, 13, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(instrumentName,"instrumentName");
            _ds.display(maxMarketOrderVolume,"maxMarketOrderVolume");
            _ds.display(minMarketOrderVolume,"minMarketOrderVolume");
            _ds.display(volumeMultiple,"volumeMultiple");
            _ds.display(priceTick,"priceTick");
            _ds.display(createDate,"createDate");
            _ds.display(openDate,"openDate");
            _ds.display(expireDate,"expireDate");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(instrumentName, true);
            _ds.displaySimple(maxMarketOrderVolume, true);
            _ds.displaySimple(minMarketOrderVolume, true);
            _ds.displaySimple(volumeMultiple, true);
            _ds.displaySimple(priceTick, true);
            _ds.displaySimple(createDate, true);
            _ds.displaySimple(openDate, true);
            _ds.displaySimple(expireDate, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
        std::string instrumentId;
        std::string instrumentName;
        tars::Int32 maxMarketOrderVolume;
        tars::Int32 minMarketOrderVolume;
        tars::Int32 volumeMultiple;
        tars::Double priceTick;
        std::string createDate;
        std::string openDate;
        std::string expireDate;
    };
    inline bool operator==(const instrumentQueryResponse&l, const instrumentQueryResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg && l.instrumentId == r.instrumentId && l.instrumentName == r.instrumentName && l.maxMarketOrderVolume == r.maxMarketOrderVolume && l.minMarketOrderVolume == r.minMarketOrderVolume && l.volumeMultiple == r.volumeMultiple && l.priceTick == r.priceTick && l.createDate == r.createDate && l.openDate == r.openDate && l.expireDate == r.expireDate;
    }
    inline bool operator!=(const instrumentQueryResponse&l, const instrumentQueryResponse&r)
    {
        return !(l == r);
    }

    struct instrumentCommissionQueryRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.instrumentCommissionQueryRequest";
        }
        static string MD5()
        {
            return "0fb14f448998d8f04299947f1c333122";
        }
        instrumentCommissionQueryRequest()
        :typeId(""),requestId(0),brokerId(""),userId(""),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            brokerId = "";
            userId = "";
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(brokerId, 3);
            _os.write(userId, 4);
            _os.write(instrumentId, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(brokerId, 3, true);
            _is.read(userId, 4, true);
            _is.read(instrumentId, 5, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(brokerId,"brokerId");
            _ds.display(userId,"userId");
            _ds.display(instrumentId,"instrumentId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(brokerId, true);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(instrumentId, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string brokerId;
        std::string userId;
        std::string instrumentId;
    };
    inline bool operator==(const instrumentCommissionQueryRequest&l, const instrumentCommissionQueryRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.brokerId == r.brokerId && l.userId == r.userId && l.instrumentId == r.instrumentId;
    }
    inline bool operator!=(const instrumentCommissionQueryRequest&l, const instrumentCommissionQueryRequest&r)
    {
        return !(l == r);
    }

    struct instrumentCommissionQueryResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.instrumentCommissionQueryResponse";
        }
        static string MD5()
        {
            return "31a722a185cd6b5c2a7e44fa266665f2";
        }
        instrumentCommissionQueryResponse()
        :typeId(""),requestId(0),errcode(0),errmsg(""),instrumentId(""),openRatioByMoney(0),openRatioByVolume(0),closeRatioByMoney(0),closeRatioByVolume(0)
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
            instrumentId = "";
            openRatioByMoney = 0;
            openRatioByVolume = 0;
            closeRatioByMoney = 0;
            closeRatioByVolume = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
            _os.write(instrumentId, 5);
            _os.write(openRatioByMoney, 6);
            _os.write(openRatioByVolume, 7);
            _os.write(closeRatioByMoney, 8);
            _os.write(closeRatioByVolume, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(openRatioByMoney, 6, true);
            _is.read(openRatioByVolume, 7, true);
            _is.read(closeRatioByMoney, 8, true);
            _is.read(closeRatioByVolume, 9, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(openRatioByMoney,"openRatioByMoney");
            _ds.display(openRatioByVolume,"openRatioByVolume");
            _ds.display(closeRatioByMoney,"closeRatioByMoney");
            _ds.display(closeRatioByVolume,"closeRatioByVolume");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(openRatioByMoney, true);
            _ds.displaySimple(openRatioByVolume, true);
            _ds.displaySimple(closeRatioByMoney, true);
            _ds.displaySimple(closeRatioByVolume, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
        std::string instrumentId;
        tars::Double openRatioByMoney;
        tars::Double openRatioByVolume;
        tars::Double closeRatioByMoney;
        tars::Double closeRatioByVolume;
    };
    inline bool operator==(const instrumentCommissionQueryResponse&l, const instrumentCommissionQueryResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg && l.instrumentId == r.instrumentId && l.openRatioByMoney == r.openRatioByMoney && l.openRatioByVolume == r.openRatioByVolume && l.closeRatioByMoney == r.closeRatioByMoney && l.closeRatioByVolume == r.closeRatioByVolume;
    }
    inline bool operator!=(const instrumentCommissionQueryResponse&l, const instrumentCommissionQueryResponse&r)
    {
        return !(l == r);
    }

    struct bidArrayItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.bidArrayItem";
        }
        static string MD5()
        {
            return "74af33f4eff9a3a5b040fc234996489a";
        }
        bidArrayItem()
        :bidPrice(0),bidVolume(0)
        {
        }
        void resetDefautlt()
        {
            bidPrice = 0;
            bidVolume = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(bidPrice, 1);
            _os.write(bidVolume, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(bidPrice, 1, true);
            _is.read(bidVolume, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(bidPrice,"bidPrice");
            _ds.display(bidVolume,"bidVolume");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(bidPrice, true);
            _ds.displaySimple(bidVolume, false);
            return _os;
        }
    public:
        tars::Double bidPrice;
        tars::Int32 bidVolume;
    };
    inline bool operator==(const bidArrayItem&l, const bidArrayItem&r)
    {
        return l.bidPrice == r.bidPrice && l.bidVolume == r.bidVolume;
    }
    inline bool operator!=(const bidArrayItem&l, const bidArrayItem&r)
    {
        return !(l == r);
    }

    struct askArrayItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.askArrayItem";
        }
        static string MD5()
        {
            return "74af33f4eff9a3a5b040fc234996489a";
        }
        askArrayItem()
        :askPrice(0),askVolume(0)
        {
        }
        void resetDefautlt()
        {
            askPrice = 0;
            askVolume = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(askPrice, 1);
            _os.write(askVolume, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(askPrice, 1, true);
            _is.read(askVolume, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(askPrice,"askPrice");
            _ds.display(askVolume,"askVolume");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(askPrice, true);
            _ds.displaySimple(askVolume, false);
            return _os;
        }
    public:
        tars::Double askPrice;
        tars::Int32 askVolume;
    };
    inline bool operator==(const askArrayItem&l, const askArrayItem&r)
    {
        return l.askPrice == r.askPrice && l.askVolume == r.askVolume;
    }
    inline bool operator!=(const askArrayItem&l, const askArrayItem&r)
    {
        return !(l == r);
    }

    struct marketDataQueryRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.marketDataQueryRequest";
        }
        static string MD5()
        {
            return "bed05919c3d64eb43899b8d1fbfbd341";
        }
        marketDataQueryRequest()
        :typeId(""),requestId(0),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(instrumentId, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(instrumentId, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(instrumentId,"instrumentId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(instrumentId, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        std::string instrumentId;
    };
    inline bool operator==(const marketDataQueryRequest&l, const marketDataQueryRequest&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.instrumentId == r.instrumentId;
    }
    inline bool operator!=(const marketDataQueryRequest&l, const marketDataQueryRequest&r)
    {
        return !(l == r);
    }

    struct marketDataQueryResponse : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Center.marketDataQueryResponse";
        }
        static string MD5()
        {
            return "b428da8fc89c74f2c8beccb3709ef2f8";
        }
        marketDataQueryResponse()
        :typeId(""),requestId(0),errcode(0),errmsg(""),instrumentId("")
        {
        }
        void resetDefautlt()
        {
            typeId = "";
            requestId = 0;
            errcode = 0;
            errmsg = "";
            instrumentId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(typeId, 1);
            _os.write(requestId, 2);
            _os.write(errcode, 3);
            _os.write(errmsg, 4);
            _os.write(instrumentId, 5);
            _os.write(bidArrayItems, 6);
            _os.write(askArrayItems, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(typeId, 1, true);
            _is.read(requestId, 2, true);
            _is.read(errcode, 3, true);
            _is.read(errmsg, 4, true);
            _is.read(instrumentId, 5, true);
            _is.read(bidArrayItems, 6, true);
            _is.read(askArrayItems, 7, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(typeId,"typeId");
            _ds.display(requestId,"requestId");
            _ds.display(errcode,"errcode");
            _ds.display(errmsg,"errmsg");
            _ds.display(instrumentId,"instrumentId");
            _ds.display(bidArrayItems,"bidArrayItems");
            _ds.display(askArrayItems,"askArrayItems");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(typeId, true);
            _ds.displaySimple(requestId, true);
            _ds.displaySimple(errcode, true);
            _ds.displaySimple(errmsg, true);
            _ds.displaySimple(instrumentId, true);
            _ds.displaySimple(bidArrayItems, true);
            _ds.displaySimple(askArrayItems, false);
            return _os;
        }
    public:
        std::string typeId;
        tars::Int32 requestId;
        tars::Int32 errcode;
        std::string errmsg;
        std::string instrumentId;
        vector<Center::bidArrayItem> bidArrayItems;
        vector<Center::askArrayItem> askArrayItems;
    };
    inline bool operator==(const marketDataQueryResponse&l, const marketDataQueryResponse&r)
    {
        return l.typeId == r.typeId && l.requestId == r.requestId && l.errcode == r.errcode && l.errmsg == r.errmsg && l.instrumentId == r.instrumentId && l.bidArrayItems == r.bidArrayItems && l.askArrayItems == r.askArrayItems;
    }
    inline bool operator!=(const marketDataQueryResponse&l, const marketDataQueryResponse&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class TraderServantPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~TraderServantPrxCallback(){}
        virtual void callback_instrumentCommissionQuery(tars::Int32 ret,  const Center::instrumentCommissionQueryResponse& rsp)
        { throw std::runtime_error("callback_instrumentCommissionQuery() override incorrect."); }
        virtual void callback_instrumentCommissionQuery_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_instrumentCommissionQuery_exception() override incorrect."); }

        virtual void callback_instrumentQuery(tars::Int32 ret,  const Center::instrumentQueryResponse& rsp)
        { throw std::runtime_error("callback_instrumentQuery() override incorrect."); }
        virtual void callback_instrumentQuery_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_instrumentQuery_exception() override incorrect."); }

        virtual void callback_marketDataQuery(tars::Int32 ret,  const Center::marketDataQueryResponse& rsp)
        { throw std::runtime_error("callback_marketDataQuery() override incorrect."); }
        virtual void callback_marketDataQuery_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_marketDataQuery_exception() override incorrect."); }

        virtual void callback_orderClose(tars::Int32 ret,  const Center::orderCloseResponse& rsp)
        { throw std::runtime_error("callback_orderClose() override incorrect."); }
        virtual void callback_orderClose_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_orderClose_exception() override incorrect."); }

        virtual void callback_orderOpen(tars::Int32 ret,  const Center::orderOpenResponse& rsp)
        { throw std::runtime_error("callback_orderOpen() override incorrect."); }
        virtual void callback_orderOpen_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_orderOpen_exception() override incorrect."); }

        virtual void callback_userLogin(tars::Int32 ret,  const Center::userLoginResponse& rsp)
        { throw std::runtime_error("callback_userLogin() override incorrect."); }
        virtual void callback_userLogin_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_userLogin_exception() override incorrect."); }

        virtual void callback_userLogout(tars::Int32 ret,  const Center::userLogoutResponse& rsp)
        { throw std::runtime_error("callback_userLogout() override incorrect."); }
        virtual void callback_userLogout_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_userLogout_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TraderServant_all[]=
            {
                "instrumentCommissionQuery",
                "instrumentQuery",
                "marketDataQuery",
                "orderClose",
                "orderOpen",
                "userLogin",
                "userLogout"
            };
            pair<string*, string*> r = equal_range(__TraderServant_all, __TraderServant_all+7, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TraderServant_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentCommissionQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::instrumentCommissionQueryResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_instrumentCommissionQuery(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::instrumentQueryResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_instrumentQuery(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_marketDataQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::marketDataQueryResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_marketDataQuery(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderClose_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::orderCloseResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_orderClose(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderOpen_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::orderOpenResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_orderOpen(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogin_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::userLoginResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_userLogin(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogout_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    Center::userLogoutResponse rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_userLogout(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<TraderServantPrxCallback> TraderServantPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class TraderServantPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~TraderServantPrxCallbackPromise(){}
    public:
        struct PromiseinstrumentCommissionQuery: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::instrumentCommissionQueryResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQuery > PromiseinstrumentCommissionQueryPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr > &promise)
        : _promise_instrumentCommissionQuery(promise)
        {}
        
        virtual void callback_instrumentCommissionQuery(const TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr &ptr)
        {
            _promise_instrumentCommissionQuery.setValue(ptr);
        }
        virtual void callback_instrumentCommissionQuery_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:instrumentCommissionQuery_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_instrumentCommissionQuery.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr > _promise_instrumentCommissionQuery;

    public:
        struct PromiseinstrumentQuery: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::instrumentQueryResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseinstrumentQuery > PromiseinstrumentQueryPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr > &promise)
        : _promise_instrumentQuery(promise)
        {}
        
        virtual void callback_instrumentQuery(const TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr &ptr)
        {
            _promise_instrumentQuery.setValue(ptr);
        }
        virtual void callback_instrumentQuery_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:instrumentQuery_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_instrumentQuery.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr > _promise_instrumentQuery;

    public:
        struct PromisemarketDataQuery: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::marketDataQueryResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromisemarketDataQuery > PromisemarketDataQueryPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr > &promise)
        : _promise_marketDataQuery(promise)
        {}
        
        virtual void callback_marketDataQuery(const TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr &ptr)
        {
            _promise_marketDataQuery.setValue(ptr);
        }
        virtual void callback_marketDataQuery_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:marketDataQuery_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_marketDataQuery.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr > _promise_marketDataQuery;

    public:
        struct PromiseorderClose: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::orderCloseResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseorderClose > PromiseorderClosePtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseorderClosePtr > &promise)
        : _promise_orderClose(promise)
        {}
        
        virtual void callback_orderClose(const TraderServantPrxCallbackPromise::PromiseorderClosePtr &ptr)
        {
            _promise_orderClose.setValue(ptr);
        }
        virtual void callback_orderClose_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:orderClose_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_orderClose.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseorderClosePtr > _promise_orderClose;

    public:
        struct PromiseorderOpen: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::orderOpenResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseorderOpen > PromiseorderOpenPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseorderOpenPtr > &promise)
        : _promise_orderOpen(promise)
        {}
        
        virtual void callback_orderOpen(const TraderServantPrxCallbackPromise::PromiseorderOpenPtr &ptr)
        {
            _promise_orderOpen.setValue(ptr);
        }
        virtual void callback_orderOpen_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:orderOpen_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_orderOpen.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseorderOpenPtr > _promise_orderOpen;

    public:
        struct PromiseuserLogin: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::userLoginResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseuserLogin > PromiseuserLoginPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLoginPtr > &promise)
        : _promise_userLogin(promise)
        {}
        
        virtual void callback_userLogin(const TraderServantPrxCallbackPromise::PromiseuserLoginPtr &ptr)
        {
            _promise_userLogin.setValue(ptr);
        }
        virtual void callback_userLogin_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:userLogin_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_userLogin.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLoginPtr > _promise_userLogin;

    public:
        struct PromiseuserLogout: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            Center::userLogoutResponse rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TraderServantPrxCallbackPromise::PromiseuserLogout > PromiseuserLogoutPtr;

        TraderServantPrxCallbackPromise(const promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLogoutPtr > &promise)
        : _promise_userLogout(promise)
        {}
        
        virtual void callback_userLogout(const TraderServantPrxCallbackPromise::PromiseuserLogoutPtr &ptr)
        {
            _promise_userLogout.setValue(ptr);
        }
        virtual void callback_userLogout_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:userLogout_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_userLogout.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLogoutPtr > _promise_userLogout;

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TraderServant_all[]=
            {
                "instrumentCommissionQuery",
                "instrumentQuery",
                "marketDataQuery",
                "orderClose",
                "orderOpen",
                "userLogin",
                "userLogout"
            };

            pair<string*, string*> r = equal_range(__TraderServant_all, __TraderServant_all+7, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TraderServant_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentCommissionQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr ptr = new TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQuery();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_instrumentCommissionQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_instrumentCommissionQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_instrumentCommissionQuery(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr ptr = new TraderServantPrxCallbackPromise::PromiseinstrumentQuery();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_instrumentQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_instrumentQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_instrumentQuery(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_marketDataQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr ptr = new TraderServantPrxCallbackPromise::PromisemarketDataQuery();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_marketDataQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_marketDataQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_marketDataQuery(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderClose_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseorderClosePtr ptr = new TraderServantPrxCallbackPromise::PromiseorderClose();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_orderClose_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_orderClose_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_orderClose(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderOpen_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseorderOpenPtr ptr = new TraderServantPrxCallbackPromise::PromiseorderOpen();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_orderOpen_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_orderOpen_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_orderOpen(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogin_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseuserLoginPtr ptr = new TraderServantPrxCallbackPromise::PromiseuserLogin();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_userLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_userLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_userLogin(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogout_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TraderServantPrxCallbackPromise::PromiseuserLogoutPtr ptr = new TraderServantPrxCallbackPromise::PromiseuserLogout();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rsp, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_userLogout_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_userLogout_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_userLogout(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<TraderServantPrxCallbackPromise> TraderServantPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class TraderServantCoroPrxCallback: public TraderServantPrxCallback
    {
    public:
        virtual ~TraderServantCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TraderServant_all[]=
            {
                "instrumentCommissionQuery",
                "instrumentQuery",
                "marketDataQuery",
                "orderClose",
                "orderOpen",
                "userLogin",
                "userLogout"
            };

            pair<string*, string*> r = equal_range(__TraderServant_all, __TraderServant_all+7, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TraderServant_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentCommissionQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::instrumentCommissionQueryResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_instrumentCommissionQuery(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_instrumentCommissionQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_instrumentCommissionQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_instrumentQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::instrumentQueryResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_instrumentQuery(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_instrumentQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_instrumentQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_marketDataQuery_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::marketDataQueryResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_marketDataQuery(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_marketDataQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_marketDataQuery_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderClose_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::orderCloseResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_orderClose(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_orderClose_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_orderClose_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_orderOpen_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::orderOpenResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_orderOpen(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_orderOpen_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_orderOpen_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogin_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::userLoginResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_userLogin(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_userLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_userLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_userLogout_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        Center::userLogoutResponse rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response.context);

                        callback_userLogout(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_userLogout_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_userLogout_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<TraderServantCoroPrxCallback> TraderServantCoroPrxCallbackPtr;

    /* proxy for client */
    class TraderServantProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 instrumentCommissionQuery(const Center::instrumentCommissionQueryRequest & req,Center::instrumentCommissionQueryResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"instrumentCommissionQuery", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_instrumentCommissionQuery(TraderServantPrxCallbackPtr callback,const Center::instrumentCommissionQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentCommissionQuery", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr > promise_async_instrumentCommissionQuery(const Center::instrumentCommissionQueryRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentCommissionQueryPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentCommissionQuery", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_instrumentCommissionQuery(TraderServantCoroPrxCallbackPtr callback,const Center::instrumentCommissionQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentCommissionQuery", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 instrumentQuery(const Center::instrumentQueryRequest & req,Center::instrumentQueryResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"instrumentQuery", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_instrumentQuery(TraderServantPrxCallbackPtr callback,const Center::instrumentQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentQuery", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr > promise_async_instrumentQuery(const Center::instrumentQueryRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseinstrumentQueryPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentQuery", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_instrumentQuery(TraderServantCoroPrxCallbackPtr callback,const Center::instrumentQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"instrumentQuery", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 marketDataQuery(const Center::marketDataQueryRequest & req,Center::marketDataQueryResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"marketDataQuery", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_marketDataQuery(TraderServantPrxCallbackPtr callback,const Center::marketDataQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"marketDataQuery", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr > promise_async_marketDataQuery(const Center::marketDataQueryRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromisemarketDataQueryPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"marketDataQuery", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_marketDataQuery(TraderServantCoroPrxCallbackPtr callback,const Center::marketDataQueryRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"marketDataQuery", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 orderClose(const Center::orderCloseRequest & req,Center::orderCloseResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"orderClose", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_orderClose(TraderServantPrxCallbackPtr callback,const Center::orderCloseRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderClose", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseorderClosePtr > promise_async_orderClose(const Center::orderCloseRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseorderClosePtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderClose", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_orderClose(TraderServantCoroPrxCallbackPtr callback,const Center::orderCloseRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderClose", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 orderOpen(const Center::orderOpenRequest & req,Center::orderOpenResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"orderOpen", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_orderOpen(TraderServantPrxCallbackPtr callback,const Center::orderOpenRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderOpen", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseorderOpenPtr > promise_async_orderOpen(const Center::orderOpenRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseorderOpenPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderOpen", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_orderOpen(TraderServantCoroPrxCallbackPtr callback,const Center::orderOpenRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"orderOpen", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 userLogin(const Center::userLoginRequest & req,Center::userLoginResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"userLogin", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_userLogin(TraderServantPrxCallbackPtr callback,const Center::userLoginRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogin", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseuserLoginPtr > promise_async_userLogin(const Center::userLoginRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLoginPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogin", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_userLogin(TraderServantCoroPrxCallbackPtr callback,const Center::userLoginRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogin", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 userLogout(const Center::userLogoutRequest & req,Center::userLogoutResponse &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"userLogout", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_userLogout(TraderServantPrxCallbackPtr callback,const Center::userLogoutRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogout", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TraderServantPrxCallbackPromise::PromiseuserLogoutPtr > promise_async_userLogout(const Center::userLogoutRequest &req,const map<string, string>& context)
        {
            promise::Promise< TraderServantPrxCallbackPromise::PromiseuserLogoutPtr > promise;
            TraderServantPrxCallbackPromisePtr callback = new TraderServantPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogout", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_userLogout(TraderServantCoroPrxCallbackPtr callback,const Center::userLogoutRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"userLogout", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        TraderServantProxy* tars_hash(int64_t key)
        {
            return (TraderServantProxy*)ServantProxy::tars_hash(key);
        }

        TraderServantProxy* tars_consistent_hash(int64_t key)
        {
            return (TraderServantProxy*)ServantProxy::tars_consistent_hash(key);
        }

        TraderServantProxy* tars_set_timeout(int msecond)
        {
            return (TraderServantProxy*)ServantProxy::tars_set_timeout(msecond);
        }

    };
    typedef tars::TC_AutoPtr<TraderServantProxy> TraderServantPrx;

    /* servant for server */
    class TraderServant : public tars::Servant
    {
    public:
        virtual ~TraderServant(){}
        virtual tars::Int32 instrumentCommissionQuery(const Center::instrumentCommissionQueryRequest & req,Center::instrumentCommissionQueryResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_instrumentCommissionQuery(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::instrumentCommissionQueryResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 instrumentQuery(const Center::instrumentQueryRequest & req,Center::instrumentQueryResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_instrumentQuery(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::instrumentQueryResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 marketDataQuery(const Center::marketDataQueryRequest & req,Center::marketDataQueryResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_marketDataQuery(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::marketDataQueryResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 orderClose(const Center::orderCloseRequest & req,Center::orderCloseResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_orderClose(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::orderCloseResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 orderOpen(const Center::orderOpenRequest & req,Center::orderOpenResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_orderOpen(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::orderOpenResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 userLogin(const Center::userLoginRequest & req,Center::userLoginResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_userLogin(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::userLoginResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 userLogout(const Center::userLogoutRequest & req,Center::userLogoutResponse &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_userLogout(tars::TarsCurrentPtr current, tars::Int32 _ret, const Center::userLogoutResponse &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __Center__TraderServant_all[]=
            {
                "instrumentCommissionQuery",
                "instrumentQuery",
                "marketDataQuery",
                "orderClose",
                "orderOpen",
                "userLogin",
                "userLogout"
            };

            pair<string*, string*> r = equal_range(__Center__TraderServant_all, __Center__TraderServant_all+7, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Center__TraderServant_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::instrumentCommissionQueryRequest req;
                    Center::instrumentCommissionQueryResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = instrumentCommissionQuery(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::instrumentQueryRequest req;
                    Center::instrumentQueryResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = instrumentQuery(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::marketDataQueryRequest req;
                    Center::marketDataQueryResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = marketDataQuery(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::orderCloseRequest req;
                    Center::orderCloseResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = orderClose(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::orderOpenRequest req;
                    Center::orderOpenResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = orderOpen(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::userLoginRequest req;
                    Center::userLoginResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = userLogin(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    Center::userLogoutRequest req;
                    Center::userLogoutResponse rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = userLogout(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
